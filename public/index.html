<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>LiChangxin&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Font-End Blog">
<meta property="og:type" content="website">
<meta property="og:title" content="LiChangxin's Blog">
<meta property="og:url" content="http://mnichangxin.github.io/blog/index.html">
<meta property="og:site_name" content="LiChangxin's Blog">
<meta property="og:description" content="Font-End Blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LiChangxin's Blog">
<meta name="twitter:description" content="Font-End Blog">
  
    <link rel="alternate" href="/atom.xml" title="LiChangxin&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/blog/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog/" id="logo">LiChangxin&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/blog/">Home</a>
        
          <a class="main-nav-link" href="/blog/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://mnichangxin.github.io/blog"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-2016-04-04-prototype" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2016/04/19/2016-04-04-prototype/" class="article-date">
  <time datetime="2016-04-19T14:48:39.538Z" itemprop="datePublished">2016-04-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/JavaScript/">JavaScript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2016/04/19/2016-04-04-prototype/">JS原型链</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在<code>C++/Java</code>中,都是靠”类”的概念进行封装和继承的。<code>JavaScript</code>没有类这种概念，但有”对象”的概念(近期发布的的<code>ES6</code>提出了新增了类的语法)。<code>JS</code>的原型继承机制不同于传统的方式，一开始难以接受。</p>
<p>我刚开始看原型的时候，彻底被折服，<code>JS</code>的魅力大概就在这。看了不少的关于原型的博客文章，翻了几遍书，大都是众说纷纭，但基本原理是一致的。我在这写一下我的理解，其中有些晦涩难懂的地方没弄明白，敬请指正。</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>构造函数就是用new创建对象时调用的函数。构造函数也是函数，为了区别其他函数，首字母一般大写。用构造函数的好处在于，调用构造函数可以创建多个对象，其中属性和方法可以实现共享。</p>
<p>构造函数内部用<code>this</code>可以很简单的添加属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以用<code>Object.defineProperty()</code>方法初始化构造函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>, name, &#123;</span><br><span class="line">        get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;,</span><br><span class="line">        set: <span class="function"><span class="keyword">function</span>(<span class="params">newName</span>) </span>&#123;</span><br><span class="line">            name = newName;</span><br><span class="line">        &#125;,</span><br><span class="line">        enumerable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于<code>Object.defineProperty()</code>可以看我上一篇博文<a href="http://mnichangxin.github.io/2016/04/02/object/">深入理解JS对象</a></p>
<h2 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h2><p>可以把原型对象看作是对象的基类。</p>
<h3 id="鉴别原型对象"><a href="#鉴别原型对象" class="headerlink" title="鉴别原型对象"></a>鉴别原型对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPrototype</span>(<span class="params">object, name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name <span class="keyword">in</span> object &amp;&amp; !object.hasOwnProperty(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是因为<code>in</code>操作符会遍历自有属性和原型属性，<code>hasOwnProperty()</code>只会遍历自有属性。</p>
<h3 id="Prototype-属性"><a href="#Prototype-属性" class="headerlink" title="[[Prototype]]属性"></a>[[Prototype]]属性</h3><p>这个内部属性几乎是所有对象(除了<code>null</code>和<code>undfined</code>)具有的，后面会说到它的具体形式。<br>可以调用<code>Object.getPrototypeOf()</code>方法读取<code>[[Prototype]]</code>属性的值。</p>
<h3 id="构造函数中使用原型对象"><a href="#构造函数中使用原型对象" class="headerlink" title="构造函数中使用原型对象"></a>构造函数中使用原型对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayname = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果向原型添加多个属性的时候，为了避免代码冗余，可以用对象字面形式写法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    sayname: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;,</span><br><span class="line">    toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'The name is'</span> + <span class="keyword">this</span>.name);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但是，有一个问题要注意，书上是这么说的：</p>
<p>当一个函数被创建时，它的<code>prototype</code>属性也被创建，且该原型对象的<code>constructor</code><br>指向该函数。当使用对象字面形式改写原型对象时，其<code>constructor</code><br>属性将被置为泛用对象<code>Object</code>。</p>
<p>为了避免这种情况发生，需要重置其<code>constructor</code>属性，即在对象里面添加：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>: Person;</span><br></pre></td></tr></table></figure>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>另外，通过冻结对象或封印对象是在操作对象的自有属性，仍然可以在原型对象添加属性<br>，因为没有冻结指向原型的指针。</p>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>以下面为例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 构造函数对象 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.sayname = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f1 = <span class="keyword">new</span> Foo(<span class="string">'John'</span>);</span><br><span class="line"><span class="keyword">var</span> f2 = <span class="keyword">new</span> Foo(<span class="string">'Tony'</span>);</span><br><span class="line"><span class="comment">/* 普通对象 */</span></span><br><span class="line"><span class="keyword">var</span> o1 = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure>
<p>上面创建了利用构造函数创建了两个对象，利用<code>Object</code>通用类创建了两个普通对象。</p>
<p>实际上，调用构造函数创建对象时，构造函数把<code>prototype</code>指向原型对象，原型对象回调属性<code>constructor</code>指向原构造函数，对象自动把指针指向原型对象。原型对象也是对象，会重复以上过程，这就构成了一条<strong>原型链</strong>。那什么时候到头呢？直到<code>Object</code>,<code>Object</code>的原型对象将置为<code>null</code>。</p>
<p>那么，这个指针究竟是什么呢？其实很多人以为这个指针就是<code>prototype</code>,这是一个误解，真正的指针是<code>__proto__</code>(<code>Firfox</code>暴露出来的内部属性，非正式标准，这里只是为了说明方便。最好用<code>Object.getPrototyprOf()</code>方法)。</p>
<p><code>__proto__</code>是几乎所有对象所具有的属性，除了<code>null</code>和<code>undefined</code>,而<code>prototype</code>只能是<strong>函数对象</strong>所具有的。</p>
<p>以上代码的具体情况可以看我画的这张图(来源于<a href="http://www.laruence.com/2010/05/13/1462.html" target="_blank" rel="external">鸟哥的博客</a>，我稍微改造了一下):</p>
<p><img src="http://7xr2ek.com1.z0.glb.clouddn.com/blog/image/prototype.png" alt=""></p>
<p>看了这张图，多画几遍，相信就豁然开朗了！</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://blog.rainy.im/2015/07/20/prototype-chain-in-js/" target="_blank" rel="external">图解JavaScript原型链</a></li>
<li><a href="https://blog.oyanglul.us/javascript/understand-prototype.html" target="_blank" rel="external">理解JavaScript的原型链和继承</a></li>
<li><a href="https://book.douban.com/subject/26352658/" target="_blank" rel="external">JavaScript面向对象精要</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://mnichangxin.github.io/blog/blog/2016/04/19/2016-04-04-prototype/" data-id="cin7od2m70009k49w1zzrmve2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2016-03-31-flex" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2016/04/19/2016-03-31-flex/" class="article-date">
  <time datetime="2016-04-19T14:48:39.535Z" itemprop="datePublished">2016-04-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/CSS/">CSS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2016/04/19/2016-03-31-flex/">Flex布局常用属性</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="flex容器属性"><a href="#flex容器属性" class="headerlink" title="flex容器属性"></a>flex容器属性</h2><ul>
<li><p>指定flex容器的排列方式 <code>flex-direction: row row-reverse column column-reverse</code></p>
</li>
<li><p>控制flex项目在容器中按一行或多行排列 <code>flex-wrap: nowrap wrap wrap-reverse</code></p>
</li>
<li><p>这个属性是flex-direction和flex-wrap的简写 <code>flex-flow: row|row-reverse|column|column-reverse nowrap|wrap|wrap-reverse</code></p>
</li>
<li><p>指定flex项目在容器沿着主轴在当前行的对齐方式 <code>justify-content: flex-start flex-end space-between space-around</code></p>
</li>
<li><p>指定flex容器内的行在flex容器中侧轴排列方式（多行生效）<code>align-content: stretch flex-start flex-end center space-between space-around</code></p>
</li>
<li><p>指定flex项目在容器沿着侧轴在当前行的对齐方式<code>align-items: stretch flex-start flex-end center baseline</code></p>
</li>
</ul>
<hr>
<h2 id="flex项目属性"><a href="#flex项目属性" class="headerlink" title="flex项目属性"></a>flex项目属性</h2><ul>
<li><p>控制flex容器中flex项目的排列顺序 <code>order: 0~</code></p>
</li>
<li><p>指定flex项目的放大比例(负数无效) <code>flex-grow: 0~</code></p>
</li>
<li><p>指定flex项目的缩小比例(负数无效) <code>flex-shrink: 0~</code></p>
</li>
<li><p>指定flex项目的大小 <code>flex-basis: auto</code> </p>
</li>
<li><p>这个属性是flex-grow、flex-shrink和flex-basis的简写 <code>flex: 0 1 auto</code></p>
</li>
<li><p>指定单个flex项目对齐方式 <code>align-self: auto</code></p>
</li>
</ul>
<hr>
<h2 id="flex项目无效属性"><a href="#flex项目无效属性" class="headerlink" title="flex项目无效属性"></a>flex项目无效属性</h2><p><code>float|clear|vertical-align</code></p>
<hr>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://segmentfault.com/a/1190000002910324" target="_blank" rel="external">Flexbox详解</a></li>
<li><a href="http://www.w3cplus.com/css3/a-visual-guide-to-css3-flexbox-properties.html" target="_blank" rel="external">图解CSS3 Flexbox属性</a></li>
<li><a href="http://www.w3cplus.com/css3/flexbox-basics.html" target="_blank" rel="external">Flexbox–快速布局神器</a></li>
<li><a href="https://demos.scotch.io/visual-guide-to-css3-flexbox-flexbox-playground/demos/" target="_blank" rel="external">Flexbox操作演示</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://mnichangxin.github.io/blog/blog/2016/04/19/2016-03-31-flex/" data-id="cin7od2m50007k49wgx1cxkv4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2016-03-10-git-command" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2016/04/19/2016-03-10-git-command/" class="article-date">
  <time datetime="2016-04-19T14:48:39.531Z" itemprop="datePublished">2016-04-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/Git/">Git</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2016/04/19/2016-03-10-git-command/">Git常用操作命令(随时更新)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="本地版本库管理"><a href="#本地版本库管理" class="headerlink" title="本地版本库管理"></a>本地版本库管理</h2><ul>
<li><p>初始化版本库： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看当前仓库状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff [--file]</span><br></pre></td></tr></table></figure>
</li>
<li><p>显示最近提交日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log [--pretty=oneline]</span><br></pre></td></tr></table></figure>
</li>
<li><p>命令记录日志查看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br></pre></td></tr></table></figure>
</li>
<li><p>当前版本、上个版本、往上N个版本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HEAD HEAD^ HEAD~N</span><br></pre></td></tr></table></figure>
</li>
<li><p>回退到上一版本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset [--hard] commit_id</span><br></pre></td></tr></table></figure>
</li>
<li><p>向暂存区添加修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add &#123;.|[--file]&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>向当前分支添加修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &apos;commit&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p>撤销修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout --file</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rm [--file]</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建标签：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag &lt;tagname&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除标签：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag &lt;tagname&gt; -d</span><br></pre></td></tr></table></figure>
</li>
<li><p>推送标签到远程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin &lt;tagname&gt; [--tags]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><ul>
<li><p>创建分支：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch &lt;name&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除分支：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d &lt;name&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看当前分支：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br></pre></td></tr></table></figure>
</li>
<li><p>切换分支: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout &lt;name&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建并切换分支：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b &lt;name&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>合并指定分支到当前分支：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge &lt;name&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>合并分支禁用Fast Forword: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge -no-ff -m &quot;commit&quot; &lt;name&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看分支合并图：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph</span><br></pre></td></tr></table></figure>
</li>
<li><p>隐藏分支：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash [list]</span><br></pre></td></tr></table></figure>
</li>
<li><p>恢复隐藏的分支: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash apply</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除隐藏的分支并恢复：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure>
</li>
<li><p>彻底删除隐藏的分支：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash drop</span><br></pre></td></tr></table></figure>
</li>
<li><p>舍弃一个没有合并过的分支：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -D &lt;name&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="远程管理"><a href="#远程管理" class="headerlink" title="远程管理"></a>远程管理</h2><ul>
<li><p>添加远程仓库引用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin &#123;&lt;SSH&gt;|&lt;HTTP&gt;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>克隆远程仓库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone origin</span><br></pre></td></tr></table></figure>
</li>
<li><p>推送到远程仓库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin branch</span><br></pre></td></tr></table></figure>
</li>
<li><p>在本地创建和远程分支对应的分支：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b branch origin/branch</span><br></pre></td></tr></table></figure>
</li>
<li><p>建立远程仓库与本地的联系：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --set-upstream-to=origin/&lt;branch&gt; branch</span><br></pre></td></tr></table></figure>
</li>
<li><p>拉取远程最新提交：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch</span><br></pre></td></tr></table></figure>
</li>
<li><p>拉取远程最新提交并合并：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除远程分支：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin :&lt;branch&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">廖雪峰的Git教程</a></li>
<li><a href="http://www.runoob.com/git/git-basic-operations.html" target="_blank" rel="external">Git基本操作</a></li>
<li><a href="http://www.runoob.com/manual/git-guide/" target="_blank" rel="external">Git简明指南</a></li>
<li><a href="http://git-scm.com/docs" target="_blank" rel="external">Git完整命令手册</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://mnichangxin.github.io/blog/blog/2016/04/19/2016-03-10-git-command/" data-id="cin7od2m10005k49wzvi6aws2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2016-03-08-github-ssh" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2016/04/19/2016-03-08-github-ssh/" class="article-date">
  <time datetime="2016-04-19T14:48:39.527Z" itemprop="datePublished">2016-04-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/GitHub/">GitHub</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2016/04/19/2016-03-08-github-ssh/">Github之SSH连接配置</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ol>
<li><p>检查密钥是否存在</p>
 <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls -al ~<span class="regexp">/.ssh</span></span><br></pre></td></tr></table></figure>
<p> 默认情况下，公共密钥的文件名是下列之一:</p>
<ul>
<li>id_dsa.pub</li>
<li>id_ecdsa.pub</li>
<li>id_ed25519.pub</li>
<li><p>id_rsa.pub</p>
<p>如果你没有一个现有的公共和私有密钥对，或不想使用任何可用连接到GitHub，请到第二步生成一个新的SSH密钥；否则到第三步。</p>
</li>
</ul>
</li>
<li><p>生成一个新的密钥 </p>
 <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -b <span class="number">4096</span> -C <span class="string">"your_email@example.com"</span></span><br><span class="line"></span><br><span class="line">Enter a file <span class="keyword">in</span> which to save the key (<span class="regexp">/Users/you</span><span class="regexp">/.ssh/id</span>_rsa): [Press enter]</span><br><span class="line"></span><br><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase): [Type a passphrase]</span><br><span class="line"></span><br><span class="line">Enter same passphrase <span class="symbol">again:</span> [Type passphrase again]</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加SSH代理</p>
 <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ eval <span class="string">"$(ssh-agent -s)"</span></span><br><span class="line"></span><br><span class="line">$ ssh-add ~<span class="regexp">/.ssh/id</span>_rsa</span><br></pre></td></tr></table></figure>
<p> 添加你的SSH密钥的SSH代理。如果你使用一个现有的SSH密钥，而不是产生一个新的SSH密钥，您需要与您现有的私钥文件名取代<code>id_rsa</code>。</p>
</li>
<li><p>复制密钥到Github</p>
 <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ clip &lt; ~<span class="regexp">/.ssh/id</span>_rsa.pub</span><br></pre></td></tr></table></figure>
<p> <code>id_rsa</code>是你自己的文件名，这句将密钥复制到粘贴板，到Github的账户设置新建密钥粘贴即可</p>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>详情见Github官网：<a href="https://help.github.com/articles/generating-an-ssh-key/" target="_blank" rel="external">Generating an SSH key</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://mnichangxin.github.io/blog/blog/2016/04/19/2016-03-08-github-ssh/" data-id="cin7od2lv0004k49wdv043v38" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2016-02-21-js-performance" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2016/04/19/2016-02-21-js-performance/" class="article-date">
  <time datetime="2016-04-19T14:48:39.522Z" itemprop="datePublished">2016-04-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/JavaScript/">JavaScript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2016/04/19/2016-02-21-js-performance/">JavaScript的性能优化：加载和执行</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>随着 Web2.0 技术的不断推广，越来越多的应用使用JavaScript技术在客户端进行处理，从而使JavaScript在浏览器中的性能成为开发者所面临的最重要的可用性问题。而这个问题又因JavaScript 的阻塞特性变的复杂，也就是说当浏览器在执行JavaScript代码时，不能同时做其他任何事情。本文详细介绍了如何正确的加载和执行JavaScript代码，从而提高其在浏览器中的性能。</p>
<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>无论当前 JavaScript 代码是内嵌还是在外链文件中，页面的下载和渲染都必须停下来等待脚本执行完成。JavaScript 执行过程耗时越久，浏览器等待响应用户输入的时间就越长。浏览器在下载和执行脚本时出现阻塞的原因在于，脚本可能会改变页面或 JavaScript 的命名空间，它们对后面页面内容造成影响。一个典型的例子就是在页面中使用<code>document.write()</code>。例如清单 1</p>
<p><strong>清单 1 JavaScript代码内嵌示例</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Source Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span><br><span class="line">        document.write("Today is " + (new Date()).toDateString());</span><br><span class="line">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当浏览器遇到<code>&lt;script&gt;</code>标签时，当前 HTML 页面无从获知 JavaScript 是否会向<code>&lt;p&gt;</code> 标签添加内容，或引入其他元素，或甚至移除该标签。因此，这时浏览器会停止处理页面，先执行 JavaScript代码，然后再继续解析和渲染页面。同样的情况也发生在使用<br><code>src</code>属性加载 JavaScript的过程中，浏览器必须先花时间下载外链文件中的代码，然后解析并执行它。在这个过程中，页面渲染和用户交互完全被阻塞了。</p>
<hr>
<h2 id="脚本位置"><a href="#脚本位置" class="headerlink" title="脚本位置"></a>脚本位置</h2><p><code>HTML 4</code> 规范指出 <code>&lt;script&gt;</code> 标签可以放在 HTML 文档的<code>&lt;head&gt;</code>或<code>&lt;body&gt;</code>中，并允许出现多次。Web 开发人员一般习惯在 <code>&lt;head&gt;</code>中加载外链的 JavaScript，接着用 <code>&lt;link&gt;</code>标签用来加载外链的 <code>CSS</code>  文件或者其他页面信息。例如清单 2</p>
<p><strong>清单 2 低效率脚本位置示例</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Source Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"script1.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"script2.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"script3.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"styles.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然而这种常规的做法却隐藏着严重的性能问题。在清单 2 的示例中，当浏览器解析到 <code>&lt;script&gt;</code> 标签（第 4 行）时，浏览器会停止解析其后的内容，而优先下载脚本文件，并执行其中的代码，这意味着，其后的 <code>styles.css</code>样式文件和<code>&lt;body&gt;</code>标签都无法被加载，由于<code>&lt;body&gt;</code>标签无法被加载，那么页面自然就无法渲染了。因此在该 JavaScript 代码完全执行完之前，页面都是一片空白。图 1 描述了页面加载过程中脚本和样式文件的下载过程。</p>
<p><strong>图 1 JavaScript 文件的加载和执行阻塞其他文件的下载</strong></p>
<p><img src="http://7xr2ek.com1.z0.glb.clouddn.com/blog%2Fimage%2Fjs-per1.jpg" alt=""></p>
<p>我们可以发现一个有趣的现象：第一个 JavaScript 文件开始下载，与此同时阻塞了页面其他文件的下载。此外，从 <code>script1.js</code> 下载完成到 <code>script2.js</code> 开始下载前存在一个延时，这段时间正好是 <code>script1.js</code> `文件的执行过程。每个文件必须等到前一个文件下载并执行完成才会开始下载。在这些文件逐个下载过程中，用户看到的是一片空白的页面。</p>
<p>从 <code>IE 8</code>、<code>Firefox 3.5</code>、<code>Safari 4</code> 和 <code>Chrome 2</code> 开始都允许并行下载 JavaScript 文件。这是个好消息，因为<code>&lt;script&gt;</code>标签在下载外部资源时不会阻塞其他<code>&lt;script&gt;</code>标签。遗憾的是，JavaScript 下载过程仍然会阻塞其他资源的下载，比如样式文件和图片。尽管脚本的下载过程不会互相影响，但页面仍然必须等待所有 JavaScript 代码下载并执行完成才能继续。因此，尽管最新的浏览器通过允许并行下载提高了性能，但问题尚未完全解决，脚本阻塞仍然是一个问题。</p>
<p>由于脚本会阻塞页面其他资源的下载，因此推荐将所有<code>&lt;script&gt;</code>标签尽可能放到<code>&lt;body&gt;</code>标签的底部，以尽量减少对整个页面下载的影响。例如清单 3</p>
<p><strong>清单 3 推荐的代码放置位置示例</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Source Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"styles.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Example of efficient script positioning --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"script1.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"script2.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"script3.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这段代码展示了在 HTML 文档中放置<code>&lt;script&gt;</code>标签的推荐位置。尽管脚本下载会阻塞另一个脚本，但是页面的大部分内容都已经下载完成并显示给了用户，因此页面下载不会显得太慢。这是优化 JavaScript 的首要规则：将脚本放在底部。</p>
<hr>
<h2 id="组织脚本"><a href="#组织脚本" class="headerlink" title="组织脚本"></a>组织脚本</h2><p>由于每个<code>&lt;script&gt;</code>标签初始下载时都会阻塞页面渲染，所以减少页面包含的<code>&lt;script&gt;</code>标签数量有助于改善这一情况。这不仅针对外链脚本，内嵌脚本的数量同样也要限制。浏览器在解析 HTML 页面的过程中每遇到一个<code>&lt;script&gt;</code>标签，都会因执行脚本而导致一定的延时，因此最小化延迟时间将会明显改善页面的总体性能。</p>
<p>这个问题在处理外链 JavaScript 文件时略有不同。考虑到<code>HTTP</code>请求会带来额外的性能开销，因此下载单个 <code>100Kb</code>的文件将比下载 5 个<code>20Kb</code>的文件更快。也就是说，减少页面中外链脚本的数量将会改善性能。</p>
<p>通常一个大型网站或应用需要依赖数个 JavaScript 文件。您可以把多个文件合并成一个，这样只需要引用一个<code>&lt;script&gt;</code>标签，就可以减少性能消耗。文件合并的工作可通过离线的打包工具或者一些实时的在线服务来实现。</p>
<p>需要特别提醒的是，把一段内嵌脚本放在引用外链样式表的<code>&lt;link&gt;</code>之后会导致页面阻塞去等待样式表的下载。这样做是为了确保内嵌脚本在执行时能获得最精确的样式信息。因此，建议不要把内嵌脚本紧跟在<code>&lt;link&gt;</code>标签后面。</p>
<hr>
<h2 id="无阻塞的脚本"><a href="#无阻塞的脚本" class="headerlink" title="无阻塞的脚本"></a>无阻塞的脚本</h2><p>减少 JavaScript 文件大小并限制 <code>HTTP</code>请求数在功能丰富的 Web 应用或大型网站上并不总是可行。Web 应用的功能越丰富，所需要的 JavaScript 代码就越多，尽管下载单个较大的 JavaScript 文件只产生一次 <code>HTTP</code>请求，却会锁死浏览器的一大段时间。为避免这种情况，需要通过一些特定的技术向页面中逐步加载 JavaScript 文件，这样做在某种程度上来说不会阻塞浏览器。</p>
<p>无阻塞脚本的秘诀在于，在页面加载完成后才加载 JavaScript 代码。这就意味着在 window 对象的<code>onload</code>事件触发后再下载脚本。有多种方式可以实现这一效果。</p>
<h3 id="延迟加载脚本"><a href="#延迟加载脚本" class="headerlink" title="延迟加载脚本"></a>延迟加载脚本</h3><p>HTML 4 为<code>&lt;script&gt;</code>标签定义了一个扩展属性：<code>defer</code>。<code>Defer</code> 属性指明本元素所含的脚本不会修改 DOM，因此代码能安全地延迟执行。<code>defer</code> 属性只被 <code>IE 4</code> 和 <code>Firefox 3.5</code> 更高版本的浏览器所支持，所以它不是一个理想的跨浏览器解决方案。在其他浏览器中，<code>defer</code> 属性会被直接忽略，因此<code>&lt;script&gt;</code>标签会以默认的方式处理，也就是说会造成阻塞。然而，如果您的目标浏览器支持的话，这仍然是个有用的解决方案。清单 4 是一个例子</p>
<p><strong>清单 4 defer 属性使用方法示例</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"script1.js"</span> <span class="attr">defer</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>带有 <code>defer</code>属性的<code>&lt;script&gt;</code>标签可以放置在文档的任何位置。对应的 JavaScript 文件将在页面解析到<code>&lt;script&gt;</code>标签时开始下载，但不会执行，直到 <code>DOM</code>加载完成，即<code>onload</code>事件触发前才会被执行。当一个带有 <code>defer</code>属性的 JavaScript 文件下载时，它不会阻塞浏览器的其他进程，因此这类文件可以与其他资源文件一起并行下载。</p>
<p>任何带有<code>defer</code> 属性的<code>&lt;script&gt;</code>元素在 <code>DOM</code> 完成加载之前都不会被执行，无论内嵌或者是外链脚本都是如此。清单 5 的例子展示了<code>defer</code>属性如何影响脚本行为：</p>
<p><strong>清单 5 defer 属性对脚本行为的影响</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Script Defer Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">defer</span>&gt;</span><span class="undefined"></span><br><span class="line">        alert("defer");</span><br><span class="line">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span><br><span class="line">        alert("script");</span><br><span class="line">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span><br><span class="line">        window.onload = function()&#123;</span><br><span class="line">            alert("load");</span><br><span class="line">        &#125;;</span><br><span class="line">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这段代码在页面处理过程中弹出三次对话框。不支持 <code>defer</code> 属性的浏览器的弹出顺序是：“<code>defer</code>”、“<code>script</code>”、“<code>load</code>”。而在支持 <code>defer</code> 属性的浏览器上，弹出的顺序则是：“<code>script</code>”、“<code>defer</code>”、“<code>load</code>”。请注意，带有 <code>defer</code> 属性的<code>&lt;script&gt;</code>元素不是跟在第二个后面执行，而是在 <code>onload</code>事件被触发前被调用。</p>
<p>如果您的目标浏览器只包括 <code>Internet Explorer</code> 和 <code>Firefox 3.5</code>，那么 <code>defer</code> 脚本确实有用。如果您需要支持跨领域的多种浏览器，那么还有更一致的实现方式。</p>
<p><code>HTML 5</code>为<code>&lt;script&gt;</code>标签定义了一个新的扩展属性：<code>async</code>。它的作用和 <code>defer</code>一样，能够异步地加载和执行脚本，不因为加载脚本而阻塞页面的加载。但是有一点需要注意，在有 <code>async</code>的情况下，JavaScript 脚本一旦下载好了就会执行，所以很有可能不是按照原本的顺序来执行的。如果 JavaScript 脚本前后有依赖性，使用 <code>async</code> 就很有可能出现错误。</p>
<h3 id="动态脚本元素"><a href="#动态脚本元素" class="headerlink" title="动态脚本元素"></a>动态脚本元素</h3><p>文档对象模型（DOM）允许您使用 JavaScript 动态创建 <code>HTML</code> 的几乎全部文档内容。<code>&lt;script&gt;</code>元素与页面其他元素一样，可以非常容易地通过标准 <code>DOM</code> 函数创建：</p>
<p><strong>清单 6 通过标准 DOM 函数创建<code>&lt;script&gt;</code>元素</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement (<span class="string">"script"</span>);</span><br><span class="line">script.type = <span class="string">"text/javascript"</span>;</span><br><span class="line">script.src = <span class="string">"script1.js"</span>;</span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>].appendChild(script);</span><br></pre></td></tr></table></figure>
<p>新的<code>&lt;script&gt;</code>元素加载 <code>script1.js</code> 源文件。此文件当元素添加到页面之后立刻开始下载。此技术的重点在于：无论在何处启动下载，文件的下载和运行都不会阻塞其他页面处理过程。您甚至可以将这些代码放在<code>&lt;head&gt;</code>部分而不会对其余部分的页面代码造成影响（除了用于下载文件的<code>HTTP</code> 连接）。</p>
<p>当文件使用动态脚本节点下载时，返回的代码通常立即执行（除了 <code>Firefox</code> 和 <code>Opera</code>，他们将等待此前的所有动态脚本节点执行完毕）。当脚本是“自运行”类型时，这一机制运行正常，但是如果脚本只包含供页面其他脚本调用调用的接口，则会带来问题。这种情况下，您需要跟踪脚本下载完成并是否准备妥善。可以使用动态 <code>&lt;script&gt;</code> 节点发出事件得到相关信息。</p>
<p><code>Firefox</code>、<code>Opera</code>, <code>Chorme</code> 和 <code>Safari 3+</code>会在<code>&lt;script&gt;</code>节点接收完成之后发出一个 <code>onload</code> 事件。您可以监听这一事件，以得到脚本准备好的通知：</p>
<p><strong>清单 7 通过监听 onload 事件加载 JavaScript 脚本</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement (<span class="string">"script"</span>)</span><br><span class="line">script.type = <span class="string">"text/javascript"</span>;</span><br><span class="line"><span class="comment">//Firefox, Opera, Chrome, Safari 3+</span></span><br><span class="line">script.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"Script loaded!"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">script.src = <span class="string">"script1.js"</span>;</span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>].appendChild(script);</span><br></pre></td></tr></table></figure>
<p><code>Internet Explorer</code>支持另一种实现方式，它发出一个 <code>readystatechange</code> 事件。<code>&lt;script&gt;</code>元素有一个 <code>readyState</code>属性，它的值随着下载外部文件的过程而改变。<code>readyState</code>有五种取值：</p>
<ul>
<li>“uninitialized”：默认状态</li>
<li>“loading”：下载开始</li>
<li>“loaded”：下载完成</li>
<li>“interactive”：下载完成但尚不可用</li>
<li>“complete”：所有数据已经准备好</li>
</ul>
<p>微软文档上说，在<code>&lt;script&gt;</code>元素的生命周期中，<code>readyState</code>的这些取值不一定全部出现，但并没有指出哪些取值总会被用到。实践中，我们最感兴趣的是“<code>loaded</code>”和“<code>complete</code>”状态。<code>Internet Explorer</code> 对这两个 <code>readyState</code> 值所表示的最终状态并不一致，有时<code>&lt;script&gt;</code>元素会得到“<code>loader</code>”却从不出现“<code>complete</code>”，但另外一些情况下出现“<code>complete</code>”而用不到“<code>loaded</code>”。最安全的办法就是在 <code>readystatechange</code> 事件中检查这两种状态，并且当其中一种状态出现时，删除 <code>readystatechange</code> 事件句柄（保证事件不会被处理两次）：</p>
<p><strong>清单 8 通过检查 readyState 状态加载 JavaScript 脚本</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>)</span><br><span class="line">script.type = <span class="string">"text/javascript"</span>;</span><br><span class="line"><span class="comment">//Internet Explorer</span></span><br><span class="line">script.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (script.readyState == <span class="string">"loaded"</span> || script.readyState == <span class="string">"complete"</span>)&#123;</span><br><span class="line">           script.onreadystatechange = <span class="literal">null</span>;</span><br><span class="line">           alert(<span class="string">"Script loaded."</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br><span class="line">script.src = <span class="string">"script1.js"</span>;</span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>].appendChild(script);</span><br></pre></td></tr></table></figure>
<p>大多数情况下，您希望调用一个函数就可以实现 JavaScript 文件的动态加载。下面的函数封装了标准实现和 <code>IE</code> 实现所需的功能：</p>
<p><strong>清单 9 通过函数进行封装</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params">url, callback</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement (<span class="string">"script"</span>)</span><br><span class="line">    script.type = <span class="string">"text/javascript"</span>;</span><br><span class="line">    <span class="keyword">if</span> (script.readyState)&#123; <span class="comment">//IE</span></span><br><span class="line">        script.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (script.readyState == <span class="string">"loaded"</span> || script.readyState == <span class="string">"complete"</span>)&#123;</span><br><span class="line">                script.onreadystatechange = <span class="literal">null</span>;</span><br><span class="line">                callback();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//Others</span></span><br><span class="line">        script.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            callback();</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    script.src = url;</span><br><span class="line">    <span class="built_in">document</span>.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>].appendChild(script);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此函数接收两个参数：JavaScript 文件的 <code>URL</code>，和一个当 JavaScript 接收完成时触发的回调函数。属性检查用于决定监视哪种事件。最后一步，设置<code>src</code> 属性，并将<code>&lt;script&gt;</code>元素添加至页面。此 <code>loadScript()</code> 函数使用方法如下：</p>
<p><strong>清单 10 loadScript()函数使用方法</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loadScript(<span class="string">"script1.js"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"File is loaded!"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>您可以在页面中动态加载很多 JavaScript 文件，但要注意，浏览器不保证文件加载的顺序。所有主流浏览器之中，只有 <code>Firefox</code> 和 <code>Opera</code> 保证脚本按照您指定的顺序执行。其他浏览器将按照服务器返回它们的次序下载并运行不同的代码文件。您可以将下载操作串联在一起以保证他们的次序，如下：</p>
<p><strong>清单 11 通过 loadScript()函数加载多个 JavaScript 脚本</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">loadScript(<span class="string">"script1.js"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    loadScript(<span class="string">"script2.js"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        loadScript(<span class="string">"script3.js"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert(<span class="string">"All files are loaded!"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>此代码等待 <code>script1.js</code> 可用之后才开始加载 <code>script2.js</code>，等 <code>script2.js</code> 可用之后才开始加载<code>script3.js</code>。虽然此方法可行，但如果要下载和执行的文件很多，还是有些麻烦。如果多个文件的次序十分重要，更好的办法是将这些文件按照正确的次序连接成一个文件。独立文件可以一次性下载所有代码（由于这是异步进行的，使用一个大文件并没有什么损失）。</p>
<p>动态脚本加载是非阻塞 JavaScript                                                下载中最常用的模式，因为它可以跨浏览器，而且简单易用。</p>
<h3 id="使用-XMLHttpRequest-XHR-对象"><a href="#使用-XMLHttpRequest-XHR-对象" class="headerlink" title="使用 XMLHttpRequest(XHR)对象"></a>使用 XMLHttpRequest(XHR)对象</h3><p>此技术首先创建一个 <code>XHR</code> 对象，然后下载 JavaScript 文件，接着用一个动态 <code>&lt;script&gt;</code> 元素将 JavaScript 代码注入页面。清单 12 是一个简单的例子：</p>
<p><strong>清单 12 通过 XHR 对象加载 JavaScript 脚本</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">"get"</span>, <span class="string">"script1.js"</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span> || xhr.status == <span class="number">304</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement (<span class="string">"script"</span>);</span><br><span class="line">            script.type = <span class="string">"text/javascript"</span>;</span><br><span class="line">            script.text = xhr.responseText;</span><br><span class="line">            <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<p>此代码向服务器发送一个获取 <code>script1.js</code> 文件的 <code>GET</code> 请求。<code>onreadystatechange</code> 事件处理函数检查 <code>readyState</code> 是不是 4，然后检查 <code>HTTP</code> 状态码是不是有效（2XX 表示有效的回应，304 表示一个缓存响应）。如果收到了一个有效的响应，那么就创建一个新的<code>&lt;script&gt;</code>元素，将它的文本属性设置为从服务器接收到的 <code>responseText</code> 字符串。这样做实际上会创建一个带有内联代码的<code>&lt;script&gt;</code>元素。一旦新<code>&lt;script&gt;</code>元素被添加到文档，代码将被执行，并准备使用。</p>
<p>这种方法的主要优点是，您可以下载不立即执行的 JavaScript 代码。由于代码返回在<code>&lt;script&gt;</code>标签之外（换句话说不受<code>&lt;script&gt;</code>标签约束），它下载后不会自动执行，这使得您可以推迟执行，直到一切都准备好了。另一个优点是，同样的代码在所有现代浏览器中都不会引发异常。</p>
<p>此方法最主要的限制是：JavaScript 文件必须与页面放置在同一个域内，不能从 <code>CDN</code> 下载（<code>CDN</code> 指”内容投递网络（<code>Content Delivery Network</code>）”，所以大型网页通常不采用 <code>XHR</code> 脚本注入技术。</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>减少 JavaScript 对性能的影响有以下几种方法：</p>
<ul>
<li>将所有的<code>&lt;script&gt;</code>标签放到页面底部，也就是<code>&lt;/body&gt;</code></li>
<li>闭合标签之前，这能确保在脚本执行前页面已经完成了渲染。</li>
<li>尽可能地合并脚本。页面中的<code>&lt;script&gt;</code>标签越少，加载也就越快，响应也越迅速。无论是外链脚本还是内嵌脚本都是如此。</li>
<li>采用无阻塞下载 JavaScript 脚本的方法：</li>
<li>使用<code>&lt;script&gt;</code>标签的 <code>defer</code> 属性（仅适用于 <code>IE</code> 和 <code>Firefox 3.5</code> 以上版本）；</li>
<li>使用动态创建的<code>&lt;script&gt;</code>元素来下载并执行代码；</li>
<li>使用 <code>XHR</code> 对象下载 JavaScript 代码并注入页面中。</li>
</ul>
<p>通过以上策略，可以在很大程度上提高那些需要使用大量 JavaScript 的 Web 网站和应用的实际性能。</p>
<hr>
<p><strong><a href="http://www.ibm.com/developerworks/cn/web/1308_caiys_jsload/index.html#ibm-pcon" target="_blank" rel="external">转载于: JavaScript 的性能优化：加载和执行</a></strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://mnichangxin.github.io/blog/blog/2016/04/19/2016-02-21-js-performance/" data-id="cin7od2ln0001k49w6movnfdo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2016-02-19-fly-layout" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2016/04/19/2016-02-19-fly-layout/" class="article-date">
  <time datetime="2016-04-19T14:48:39.501Z" itemprop="datePublished">2016-04-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/CSS/">CSS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2016/04/19/2016-02-19-fly-layout/">圣杯布局和双飞翼布局</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>话说双飞翼布局始于淘宝UED，就找来资料研究了一番，其实原理很简单。圣杯布局的来历是A list part上的一篇<a href="http://alistapart.com/article/holygrail" target="_blank" rel="external">文章</a>，另外双飞翼布局是对圣杯布局的一个改进吧。</p>
<hr>
<h2 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h2><p>实现的目的就是让左右两栏固定，中间一栏自适应。</p>
<p>先写出表现层代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"page"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"head"</span>&gt;</span>页头<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"layout"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span>我是主列<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"sub"</span>&gt;</span>我是子列<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"extra"</span>&gt;</span>我是附加列<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"foot"</span>&gt;</span>页脚<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>结构层代码如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.head</span>,<span class="selector-class">.foot</span> &#123;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#5E5E5E</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;            </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">background</span>:<span class="number">#ED1C24</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.sub</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#3F48CC</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.extra</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#22B14C</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释一下：</p>
<blockquote>
<p>三列都左浮动，main的width=100%自适应宽度，如果不为sub和extra设置负外边距，它们<br>将会被挤到下一行。于是为sub设置一个-100%的负边距，使sub列在main列的左侧，同理e<br>xtra列给它一个负外边距。</p>
</blockquote>
<p>效果如下：</p>
<p><img src="http://7xr2ek.com1.z0.glb.clouddn.com/blog%2Fimage%2Fflylayout1.png" alt=""></p>
<p>但是可以看到，sub列和extra列遮挡住了main列，于是考虑改进代码：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.layout</span>&#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">150px</span> <span class="number">0</span> <span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>给整个包含框设置左右内边距，使main列收缩，效果如下：</p>
<p><img src="http://7xr2ek.com1.z0.glb.clouddn.com/blog%2Fimage%2Fflylayout2.png" alt=""></p>
<p>这里又出现一个问题，sub列和extra列紧跟着收缩了，于是继续改进:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.sub</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#3F48CC</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">left</span>: -<span class="number">150px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.extra</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#22B14C</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">right</span>: -<span class="number">150px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>给sub列和extra列增加一个相对定位，使其移动到正确的位置，效果如下:</p>
<p><img src="http://7xr2ek.com1.z0.glb.clouddn.com/blog%2Fimage%2Fflylayout3.png" alt=""></p>
<p>很明显这就是我们想要的效果，这就是圣杯布局！</p>
<hr>
<h2 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h2><p>我们在其实在第一步就把sub列和extra列定宽固定好了，只是由于遮挡住了main列才进行的代码改进。现在试想能不能只对main列代码进行一点改动，而不去动sub列和extra列的代码?</p>
<p>下面是淘宝UED给出的改进方案：</p>
<p><strong>给main列增加一个包裹层：</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main-wrap"</span>&gt;</span>我是主列<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>给包裹层设置左右外边距</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.main-wrap</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">150px</span> <span class="number">0</span> <span class="number">150px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果和圣杯布局一样：</p>
<p><img src="http://7xr2ek.com1.z0.glb.clouddn.com/blog%2Fimage%2Fflylayout4.png" alt=""></p>
<blockquote>
<p>一切如此简单！除了添加了一个额外标签，其它各方面，表现都很完美（试了下IE5.5,<br>也没任何问题）。目前只用到了浮动和负边距，如果再引入相对定位，还可以实现三栏布<br>局的各种组合</p>
</blockquote>
<p>个人觉得双飞翼布局比圣杯布局更为简洁。</p>
<hr>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="http://www.imooc.com/wenda/detail/254035" target="_blank" rel="external">双飞翼布局介绍-始于淘宝UED</a></li>
<li><a href="http://www.cnblogs.com/langzs/archive/2013/01/27/taobaoshuangfeiyi.html" target="_blank" rel="external">CSS布局之—淘宝双飞翼布局</a></li>
<li><a href="http://www.css88.com/archives/1370" target="_blank" rel="external">射雕双飞翼布局的几个补充布局</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://mnichangxin.github.io/blog/blog/2016/04/19/2016-02-19-fly-layout/" data-id="cin7od2lu0003k49wnbt9dvy1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2016-02-03-jekyll-build" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2016/04/19/2016-02-03-jekyll-build/" class="article-date">
  <time datetime="2016-04-19T14:48:39.482Z" itemprop="datePublished">2016-04-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/GitHub/">GitHub</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2016/04/19/2016-02-03-jekyll-build/">jekyll静态博客搭建</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>经常写博客是一件满足的事，一直没有找到合适的博客平台，要么太臃肿，或者太简陋。之前我曾经在新浪云上搭建过一个<a href="http://mnichangxin.sinaapp.com" target="_blank" rel="external">博客</a>,功能各方面做的太渣，暂时告一段落。最近看到有人在github上做这件事，于是搜集了各方面的资料，费了几天的时间，弄出来一个简约的<a href="http://mnichangxin.github.io">博客</a>。</p>
<hr>
<h2 id="关于github-page"><a href="#关于github-page" class="headerlink" title="关于github-page"></a>关于github-page</h2><p><a href="https://pages.github.com/" target="_blank" rel="external">GitHub-page</a> 是一个免费的静态网站托管平台，由github提供，它具有以下特点：是一个免费的静态网站托管平台，由github提供，它具有以下特点：</p>
<ol>
<li>免空间费，免流量费</li>
<li>具有项目主页和个人主页两种选择</li>
<li>支持页面生成，可以使用<code>jekyll</code>来布局页面，使用<code>markdown</code>来书写正文</li>
<li>可以自定义域名</li>
</ol>
<h3 id="项目主页"><a href="#项目主页" class="headerlink" title="项目主页"></a>项目主页</h3><p>为项目提供一个展示功能的网站，主要供宣传。网站目录需要是项目仓库的<code>gh-pages</code>分支，而且还提供了众多的模版，但可定制性不高。</p>
<h3 id="个人主页"><a href="#个人主页" class="headerlink" title="个人主页"></a>个人主页</h3><p>每个账号只能有一个仓库存放个人主页，仓库名称是约定俗成的<code>username.github.io</code> ，<br>搭建完毕后可以用<code>http://username.github.io</code>访问，当然可以自定义域名，后面会讲到。整个网站目录存放在仓库的<code>master</code>分支下。</p>
<hr>
<h2 id="关于jekyll"><a href="#关于jekyll" class="headerlink" title="关于jekyll"></a>关于jekyll</h2><p>我们搭建的博客只是静态页面，如果写博客势必会写大量的标签。但是，<code>jekyll</code>出现了，而且github页面支持<code>jekyll</code>解析，这样就减少了工作量。<code>jekyll</code>安装需要<code>Ruby</code>环境，后面大量工作都是围绕这个展开。</p>
<hr>
<h2 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a>搭建过程</h2><p>主要是本地化的一些配置，搭建在Windows下进行。</p>
<ul>
<li><p>安装Ruby</p>
<p>  Windows下可以用<a href="http://rubyinstaller.org/downloads/" target="_blank" rel="external">Rubyinstall</a>傻瓜式安装,各个平台的安装方式详见<a href="http://www.ruby-lang.org/zh_cn/downloads/" target="_blank" rel="external">Ruby官网</a>，注意安装完成后要配置一下环境变量。</p>
</li>
<li><p>安装RubyDevKit</p>
<p>  下载<code>DevKit</code>,版本要与<code>ruby</code>版本一致。下载下来后解压到任意目录，cmd进入此目录，运行如下命令</p>
  <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ruby dk.rb init</span><br></pre></td></tr></table></figure>
<p>  这步会在目录下生成一个config.yml文件，这只针对<code>rubyinstall</code>安装的有效，其他方式请修改<code>config.yml</code>文件。</p>
<p>  最后，执行如下命令安装</p>
  <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ruby dk.rb install</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装Rubygems</p>
<p>  <code>gem</code>就像linux的一样。新版<code>Ruby</code>自带<code>gem</code>，安装可以跳过。可能国内网络不佳，推荐修改源，可以考虑<a href="https://ruby.taobao.org/" target="_blank" rel="external">淘宝源</a>,按照他给的方法改好后基本就能用了。</p>
</li>
<li><p>安装jekyll</p>
<p>  <code>gem</code>直接执行安装:</p>
  <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gem install jekyll</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装bundle</p>
<p>  在 <strong>项目根目录</strong>新建一个叫<code>Gemfile</code>的文件，没有后缀，编辑保存以下内容：</p>
  <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ source <span class="string">'https://ruby.taobao.org/'</span></span><br><span class="line">$ gem <span class="string">'github-pages'</span></span><br></pre></td></tr></table></figure>
<p>  然后一步安装：</p>
  <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gem install bundle</span><br></pre></td></tr></table></figure>
<p>  命令会根据当前目录下的<code>Gemfile</code>，安装所需要的所有软件。这一步所安装的东西，可以说跟github本身的环境是完全一致的，所以可以确保本地如果没有错误，上传后也不会有错误。而且可以在将来使用下面命令，随时更新环境，十分方便。</p>
  <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bundle update</span><br></pre></td></tr></table></figure>
<p>  使用以下命令，启动本地服务，这时候访问<code>localhost:4000</code>,页面出现了！</p>
</li>
</ul>
<hr>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><ul>
<li><p>使用模版</p>
<p>  <code>github</code>上提供了<code>Jekyll</code>的大量<a href="http://jekyllthemes.org/" target="_blank" rel="external">现成模版</a>，可以直接拿来用，开源的嘛。</p>
</li>
<li><p>自定义域名</p>
<p>  如果觉得域名比较土，可以自定义域名，可以去<code>godaddy</code>上看一看。</p>
</li>
<li><p>熟悉Git</p>
<p>  环境搭建成功后，就需要到<code>github</code>上提交代码了，熟悉<code>git</code>操作是必须的。</p>
</li>
</ul>
<hr>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.pchou.info/web-build/2014/07/04/build-github-blog-page-08.html" target="_blank" rel="external">一步步在github上创建博客</a></li>
<li><a href="http://jekyll.bootcss.com/docs/home/" target="_blank" rel="external">jekyll官方文档</a></li>
<li><a href="https://pages.github.com/" target="_blank" rel="external">github-page官网</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://mnichangxin.github.io/blog/blog/2016/04/19/2016-02-03-jekyll-build/" data-id="cin7od2lh0000k49w7b7k04tq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/blog/categories/CSS/">CSS</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/Git/">Git</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/GitHub/">GitHub</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/JavaScript/">JavaScript</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2016/04/">April 2016</a></li></ul>
    </div>
  </div>


  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 LiChangxin<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/blog/" class="mobile-nav-link">Home</a>
  
    <a href="/blog/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css">
  <script src="/blog/fancybox/jquery.fancybox.pack.js"></script>


<script src="/blog/js/script.js"></script>

  </div>
</body>
</html>