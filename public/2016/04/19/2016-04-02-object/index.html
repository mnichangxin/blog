<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>深入理解JS对象 | LiChangxin&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="content{:toc}

前言理解JavaScript的对象运作方式对以后理解整个JS很有帮助，下面开始介绍。
定义属性当一个属性第一次被添加给对象时，JavaScript在对象上调用一个名为[[Put]]的内部方法。[[Put]]方法会在对象上创建一个新节点来保存属性。调用[[Put]]的结果是在对象上创建了一个自有属性
当一个已有的属性被赋予一个新值时，调用的是一个名为[[Set]]的方">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解JS对象">
<meta property="og:url" content="http://mnichangxin.github.io/blog/2016/04/19/2016-04-02-object/index.html">
<meta property="og:site_name" content="LiChangxin's Blog">
<meta property="og:description" content="content{:toc}

前言理解JavaScript的对象运作方式对以后理解整个JS很有帮助，下面开始介绍。
定义属性当一个属性第一次被添加给对象时，JavaScript在对象上调用一个名为[[Put]]的内部方法。[[Put]]方法会在对象上创建一个新节点来保存属性。调用[[Put]]的结果是在对象上创建了一个自有属性
当一个已有的属性被赋予一个新值时，调用的是一个名为[[Set]]的方">
<meta property="og:updated_time" content="2016-04-02T12:49:04.425Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入理解JS对象">
<meta name="twitter:description" content="content{:toc}

前言理解JavaScript的对象运作方式对以后理解整个JS很有帮助，下面开始介绍。
定义属性当一个属性第一次被添加给对象时，JavaScript在对象上调用一个名为[[Put]]的内部方法。[[Put]]方法会在对象上创建一个新节点来保存属性。调用[[Put]]的结果是在对象上创建了一个自有属性
当一个已有的属性被赋予一个新值时，调用的是一个名为[[Set]]的方">
  
    <link rel="alternate" href="/atom.xml" title="LiChangxin&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/blog/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog/" id="logo">LiChangxin&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/blog/">Home</a>
        
          <a class="main-nav-link" href="/blog/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://mnichangxin.github.io/blog"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-2016-04-02-object" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2016/04/19/2016-04-02-object/" class="article-date">
  <time datetime="2016-04-19T14:48:39.537Z" itemprop="datePublished">2016-04-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/JavaScript/">JavaScript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      深入理解JS对象
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>content<br>{:toc}</li>
</ul>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>理解JavaScript的对象运作方式对以后理解整个JS很有帮助，下面开始介绍。</p>
<h2 id="定义属性"><a href="#定义属性" class="headerlink" title="定义属性"></a>定义属性</h2><p>当一个属性第一次被添加给对象时，JavaScript在对象上调用一个名为<code>[[Put]]</code>的内部方法。<code>[[Put]]</code>方法会在对象上创建一个新节点来保存属性。调用<code>[[Put]]</code>的结果是在对象上创建了一个自有属性</p>
<p>当一个已有的属性被赋予一个新值时，调用的是一个名为<code>[[Set]]</code>的方法</p>
<h2 id="属性探测"><a href="#属性探测" class="headerlink" title="属性探测"></a>属性探测</h2><p>检查对象是否已有一个属性，最可靠的方法是使用 <code>in</code> 操作符：<code>&#39;属性&#39; + in + 对象</code>，<code>in</code> 操作符会检查自有属性和原型属性；考虑性能问题，可以选择所有对象都拥有的<code>hasOwnProperty()</code>方法，该方法在给定属性存在且为自有属性时返回<code>ture</code></p>
<pre><code>var ob = new Object();

ob.name = &apos;mnichangxin&apos;;

Object.prototype.age = 20; //原型添加属性

/* 属性探测 */
console.log(&apos;name&apos; in ob); //true
console.log(&apos;age&apos; in ob); //true
console.log(ob.hasOwnProperty(&apos;name&apos;)); //true
console.log(ob.hasOwnProperty(&apos;age&apos;)); //false
</code></pre><hr>
<h2 id="删除属性"><a href="#删除属性" class="headerlink" title="删除属性"></a>删除属性</h2><p>使用<code>delete</code>操作符：<code>delete + 属性</code>，成功时返回<code>true</code></p>
<pre><code>/* 删除属性 */
delete ob.name;
console.log(ob.hasOwnProperty(&apos;name&apos;)); //false
</code></pre><hr>
<h2 id="属性枚举"><a href="#属性枚举" class="headerlink" title="属性枚举"></a>属性枚举</h2><p>可枚举属性的内部特征<code>[[Enumerable]]</code>都被设置为<code>true</code>,可以用<code>for-in</code>循环遍历它们；如果只需要获取一个对象的属性列表数组，可以用<code>Object.keys()</code>方法。它们的区别是:<code>for-in</code>循环同时会遍历原型属性和自有属性，而<code>Object.keys()</code>只返回自有属性</p>
<p>并不是所有属性都是可以枚举的。实际上，对象的大部分原生方法的<code>[[Enumerable]]</code>特征都被设为<code>false</code>。可以用<code>propertyIsEnumerable()</code>方法检测一个属性是否为可枚举的</p>
<pre><code>/* 属性枚举 */

//for-in循环
for(property in ob) {
    console.log(&apos;Name:&apos; + property);
    console.log(&apos;Value:&apos; + ob[property]);
}

//Object.keys()方法
var propertyList = Object.keys(ob);

for(var i = 0; i &lt; propertyList.length; ++i) {
    console.log(&apos;Name:&apos; + propertyList[i]);
    console.log(&apos;Value:&apos; + ob[propertyList[i]]);
}

//判断是否可以枚举
console.log(ob.propertyIsEnumerable(&apos;name&apos;)); //true
</code></pre><hr>
<h2 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h2><p>属性有两种类型：数据属性和访问器属性。</p>
<p><code>[[Put]]</code>方法的默认行为是创建数据属性；访问器属性不包含值而是定义了一个当属性被读取时调用的函数（称为<code>getter</code>）和一个当属性被写入时调用的函数（称为<code>setter</code>）。并不一定要同时定义getter和setter，可以选择定义其中之一（只读或只写）</p>
<hr>
<h2 id="属性特征"><a href="#属性特征" class="headerlink" title="属性特征"></a>属性特征</h2><h3 id="通用特征"><a href="#通用特征" class="headerlink" title="通用特征"></a>通用特征</h3><p>有两个特征是数据和访问器属性都具有的。一个是<code>[[Enumerable]]</code>，决定了你是否可以遍历该属性；另一个是<code>[[Configurable]]</code>，决定该属性是否可以配置。声明的所有属性默认都是可枚举、可配置的</p>
<pre><code>Object.defineProperty(ob, &apos;name&apos;, {
    enumerable: false,
    configurable: false
});
console.log(ob.propertyIsEnumerable(&apos;name&apos;)); //false
delete ob.name; //试图删除会报错
</code></pre><hr>
<h3 id="数据属性特征"><a href="#数据属性特征" class="headerlink" title="数据属性特征"></a>数据属性特征</h3><p>数据属性拥有两个特有的特征：第一个是<code>[[Value]]</code>，包含属性的值；第二个是<code>[[Writable]]</code>,指示该属性是否可以写入，默认可写。当<code>Object.defineProperty()</code>被调用时，首先检查属性是否存在。如果不存在，将根据属性描述对象指定的特征创建。用此方法时，一定要为所有的特征指定一个值，否则所有布尔类型默认设置为<code>false</code>。</p>
<pre><code>//数据属性特征值
Object.defineProperty(ob, &apos;name&apos;, {
    value: &apos;world&apos;,
    writable: true,
    enumerable: true,
    configurable: true
});
for(property in ob) {
    console.log(&apos;Name:&apos; + property);
    console.log(&apos;Value:&apos; + ob[property]);
}
</code></pre><hr>
<h3 id="访问器属性特征"><a href="#访问器属性特征" class="headerlink" title="访问器属性特征"></a>访问器属性特征</h3><p>访问器特有的属性特征：<code>[[Get]]</code> 和 <code>[[Set]]</code></p>
<p>字面形式：</p>
<pre><code>var person1 = {
    _name：‘MR’,
}
get name() {
    console.log(&apos;reading name&apos;);
    return this._name;
}
set name() {
    console.log(&apos;setting name to %s&apos;, value);
    this._name = value;
}
</code></pre><p>对象形式： </p>
<pre><code>//访问器属性特征值
ob._name = &apos;MR&apos;;
Object.defineProperty(ob, &apos;name&apos;, {
    get: function() {
        console.log(&apos;reading name&apos;);
        return this._name;
    },
    set: function(value) {
        console.log(&apos;setting name to %s&apos;, value);
        this._name = value;
    },
    enumerable: true,
    configurable: true
});
</code></pre><hr>
<h3 id="定义多重属性"><a href="#定义多重属性" class="headerlink" title="定义多重属性"></a>定义多重属性</h3><p>可以为一个对象同时定义多个属性，使用<code>Object.defineProperties()</code>方法，该方法接受两个参数：需要改变的对象和一个包含所有属性的对象</p>
<pre><code>//定义多重属性
Object.defineProperties(ob, {
     _name: {
        value: &apos;world&apos;,
        enumerable: true,
        configurable: true,
        writable: true
     },
     name: {
        get: function() {
            console.log(&apos;reading name&apos;);
            return this._name;
        },
        set: function(value) {
            console.log(&apos;setting name to %s&apos;,value);
            this._name = value;
        },
        enumerable: true,
        configurable: true
     }
});
</code></pre><hr>
<h3 id="获取属性特征"><a href="#获取属性特征" class="headerlink" title="获取属性特征"></a>获取属性特征</h3><p>使用<code>Object.getOwnPropertyDescriptor()</code>方法，只可用于自有属性。接受两个参数：对象和属性名。如果属性存在，它会返回一个属性描述对象</p>
<pre><code>//获取属性特征
var des = Object.getOwnPropertyDescriptor(ob, &apos;name&apos;);
console.log(des.enumerable);
console.log(des.configurable);
</code></pre><h2 id="禁止修改对象"><a href="#禁止修改对象" class="headerlink" title="禁止修改对象"></a>禁止修改对象</h2><h3 id="禁止扩展"><a href="#禁止扩展" class="headerlink" title="禁止扩展"></a>禁止扩展</h3><p>第一种方法是用<code>Object.preventExtensions</code>()创建一个不可扩展的对象。该方法只接受一个参数，就是传入的对象。可以用<code>Object.isExtensible()</code>检查<code>[[Extensionable]]</code>的值</p>
<pre><code>//禁止扩展
Object.preventExtensions(ob);
ob.month = 4;
console.log(ob.month); //undefined
</code></pre><hr>
<h3 id="对象封印"><a href="#对象封印" class="headerlink" title="对象封印"></a>对象封印</h3><p>第二种方法是用<code>Object.seal()</code>方法封印一个对象。该方法被调用时，<code>[[Extensible]]</code>的特征被设置为<code>false</code>，其所有属性的<code>[[Configurable]]</code>特征被设为<code>false</code>,只能读写它的属性。可以用<code>Object.isSealed()</code>判断一个对象是否被封印。</p>
<pre><code>Object.seal(ob);
ob.month = 4;
console.log(ob.month); //undefined
</code></pre><hr>
<h3 id="对象冻结"><a href="#对象冻结" class="headerlink" title="对象冻结"></a>对象冻结</h3><p>第三种方法是用<code>Object.freeze()</code>来冻结一个对象。被冻结对象是一个数据属性都为只读的被封印对象，被冻结对象无法解冻。可以用<code>Object.isFrozen()</code>判断一个对象是否被冻结。</p>
<pre><code>Object.freeze(ob);
console.log(ob.month);
console.log(ob.month); //undefined
</code></pre><hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://mnichangxin.github.io/blog/blog/2016/04/19/2016-04-02-object/" data-id="cin7jq4aw000ggc9wezgvw6nj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/blog/2016/04/19/2016-04-04-prototype/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          JS原型链
        
      </div>
    </a>
  
  
    <a href="/blog/2016/04/19/2016-03-31-flex/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Flex布局常用属性</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/blog/categories/CSS/">CSS</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/Git/">Git</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/GitHub/">GitHub</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/JavaScript/">JavaScript</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2016/04/">April 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/2016/04/19/2016-04-04-prototype/">JS原型链</a>
          </li>
        
          <li>
            <a href="/blog/2016/04/19/2016-04-02-object/">深入理解JS对象</a>
          </li>
        
          <li>
            <a href="/blog/2016/04/19/2016-03-31-flex/">Flex布局常用属性</a>
          </li>
        
          <li>
            <a href="/blog/2016/04/19/2016-03-10-git-command/">Git常用操作命令(随时更新)</a>
          </li>
        
          <li>
            <a href="/blog/2016/04/19/2016-03-08-github-ssh/">Github之SSH连接配置</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 LiChangxin<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/blog/" class="mobile-nav-link">Home</a>
  
    <a href="/blog/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css">
  <script src="/blog/fancybox/jquery.fancybox.pack.js"></script>


<script src="/blog/js/script.js"></script>

  </div>
</body>
</html>